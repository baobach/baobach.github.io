---
title: 'A Quick starting guide for QuantConnect Algorithm Framework'
date: 2024-08-30
permalink: /posts/2024/08/quantconnect-framework/
tags:
  - algorithmic trading
  - quantconnect
  - python
---

[QuantConnect](https://www.quantconnect.com) is an algorithmic trading browser-based platform that lets you develop, test and execute strategies. The platform allows us to use morden programming languages like Python and C# to build trading logics which is intuitive and straightforward for all levels of quants.

They offer terabytes of free financial data and allow both live trading (including paper trading) and backtesting of strategies using either their own data or data from a collection of leading brokerages; supporting Equities, Futures, Options, Forex, CFD, and Cryptocurrencies.

The platform is designed to be a really easy all-in-one location to get you from absolutely nothing to having fully validated and back-tested strategies running live on their infrastructure.

On top of the basic functionality, there are some really great aspects to QuantConnect such as their Strategy Development Framework (a series of pre-made plug-and-play modules covering key aspects of an algorithmic strategy that can be utilized in many different combinations) and their Alpha Stream, which is a feature that lets you attempt to monetize any strategies you might have by “leasing” them out to interested 3rd parties- who can see the insights and trading recommendations generated by your algorithms and also utilize them, without actually seeing their underlying code.

What does QuantConnect offer?
======

**Backtesting and Live trading**

Most platforms and APIs allow you to easily execute a live trading strategy through them, however, a unique aspect of QuantConnect is just how easy it is to give your strategies a thorough back-test using the platform.

All you have to do is configure a start date and end date for the backtest period, an initial cash amount to allocate to the strategy, and hit “Backtest”- and you’re off!
![Screen short of coding space](https://cdn.quantconnect.com/i/tu/qc-desktop-split-the-editor.gif)

You are then gifted with some very comprehensive backtest stats and graphs!
![Screen short of backtesting results](https://cdn.quantconnect.com/i/tu/backtest-result-page-top.png)

Backtesting is free, however, live trading will require a small investment in a monthly Quant Researcher membership ($8/month) and a live trading node ($20/month for the smallest) to power your algorithm.

**Paper trading**

When deploying a strategy to live, it is possible to elect to “paper trade” (trade using pretend money) to test your strategies before committing to using real money.

This is fantastically useful both if you are a novice to trading in general, and for all traders- beginners and experienced alike- to get a better feel that your trading strategy actually is profitable on out-of-sample data before committing to it.

Paper trading can be chosen in the “Select Brokerage” step of the Go Live flow.
![Screen short of live trading page](https://cdn.quantconnect.com/i/tu/deploy-paper-trading.gif)

**Free data**

QuantConnect offers a huge amount of free data through the QuantConnect Data Explorer.
![Screen short of data explorer](https://cdn.quantconnect.com/i/tu/view-all-dataset-listings.png)

Note that whilst this is all free to use within the IDE, it is not necessarily all free to download and use in an external environment- sometimes you will have to pay for that.

**Strategy Development Framework**

QuantConnect’s Strategy Development Framework (SDF) comprises of plug and play modules designed to make replicating, sharing, and re-using specific components of strategies as easy as possible.

It comprises 5 sections:

1. The Alpha Creation section (algorithms producing insights about markets, indicating whether an asset is expected to go up or down in price, and the magnitude, duration, and confidence of the prediction- as we just discussed).
2. Universe Selection (modules to pick which assets to trade with your strategy- filterable by all sorts of metrics such as liquidity, volatility, marketcap, etc.).
3. Portfolio Construction (modules determining the balance of funds allocated to different assets in your universe).
4. Execution (modules determining how your algorithm will reach the target allocations determined by the Portfolio Construction section. For instance immediate execution or standard deviation- where the algorithm waits for the price to move X standard deviations above or below the recent mean before executing a trade).
5. Risk Management (modules focused on minimizing risks and cutting losing positions early).

As you might have noticed, there is a clear directional flow between the modules.
![Overview of strategy development framework](https://cdn.quantconnect.com/web/i/docs/algorithm-framework/algorithm-framework.png)

To finally harvest the power of QuantConnect, I am going to show you how to build an algorithm that manage simple portfolio using prebuilt modules. This can give you a overview of how framework works and then you can start building your own modules to fit your needs.

How to use Algorithm Framework
======
The Algorithm Framework is built into the QCAlgorithm class, so your strategy can access all the normal methods you use for algorithm development. You should be able to copy and paste your algorithms across without any changes. You don't need a separate class.

In the `main.py` script, we can start by adding some of the modules to our strategy using this basic structure:

```python
class MyFrameworkAlgorithm(QCAlgorithm):
    def initialize(self) -> None:
        self.set_universe_selection(ETFConstituentsUniverseSelectionModel("SPY"))
        self.add_alpha(RsiAlphaModel())
        self.set_portfolio_construction(EqualWeightingPortfolioConstructionModel())
        self.set_execution(ImmediateExecutionModel())
        self.add_risk_management(NullRiskManagementModel())
```

The first line class `MyFrameworkAlgorithm(QCAlgorithm):` creates our algorithm. The important part is that the algorithm inherits from the `QCAlgorithm` class, allowing it to use its methods and variables, so don’t change this bit.

The `initialize(self):` runs before backtesting/live trading commences. In it we set important variables, modules, add data and warm up indicators, and so forth.

We will go through each module and what it is contributing to our strategy.

**1. Universe Selection Module**
The Universe Selection model will filter the liquid univere and returns the list of `Symbol` objects for the strategy. These symbols can be use to request data, perform trading logic and placing orders. This is important for the strategy because we want to define the type of assets we are trading and make sure we do this automatically either it is simple equity or more complex instruments like future contracts or options contract.

The pre-built module I used is the `ETFConstituentsUniverseSelectionModel("SPY")`. This model return the list of 500 companies in the S&P 500 index. This is a dynamic universe meaning if the index updates the list of it's constituents, the universe will adapt and update accordingly.

The model can take `universe_filter_func` argument to further filter the universe to select stocks that you want.

```python
# Initialize asynchronous settings for speed and use ETFConstituentsUniverseSelectionModel to select the top 10 SPY constituents by weight, focusing on blue-chip stocks with minimal risk.
def initialize(self) -> None:
    self.universe_settings.asynchronous = True   
    self.add_universe_selection(
        ETFConstituentsUniverseSelectionModel("SPY", universe_filter_func=self._etf_constituents_filter)
    )

def _etf_constituents_filter(self, constituents: List[ETFConstituentUniverse]) -> List[Symbol]:
    # Sort descending by weight and select the first 10 symbols.
    selected = sorted(
        [c for c in constituents if c.weight],
        key=lambda c: c.weight, reverse=True
    )[:10]
    return [c.symbol for c in selected]
```
**2. Alpha Module**
The Alpha model predicts market trends and signals the best moments to trade. These signals, or `Insight` objects, contain the _Direction_, _Magnitude_, and _Confidence_ of a market prediction and the suggested portfolio _Weight_. You should generate insights on the set of assets provided by the **Universe Selection** model and only generate them when your predictions change.

The `RsiAlphaModel` generates insights based on the relative strength index (RSI) indicator values. When the RSI value passes above 70, the model emits a down insight. When the RSI value passes below 30, the model emits an up insight. The model uses the Wilder moving average type and sets the duration of `Insight` objects to be the product of the resolution and period arguments.

**3. Portfolio Construction Module**
The Portfolio Construction model receives `Insight` objects from the **Alpha** model and creates `PortfolioTarget` objects for the **Risk Management** model. A `PortfolioTarget` provides the allocated weights for each asset in the portfolio.

The `EqualWeightingPortfolioConstructionModel` assigns an equal share of the portfolio to the securities with active insights. This weighting scheme is useful for universe rotation based on simple portfolio strategies. The model takes a `Resolution` argument to determine the rebalancing period. 

**4. Risk Management Module**
The Risk Management model seeks to manage risk on the `PortfolioTarget` collection it receives from the **Portfolio Construction** model before the targets reach the Execution model. There are many creative ways to manage risk. 

The `NullRiskManagementModel` is the default **Risk Management** model. It doesn't adjust any of the `PortfolioTarget` objects it receives from the Portfolio Construction model. This is helpful when we first started the strategy and then later implement a suitable model to reduce the risk exposure of the strategy.

**5. Execution Module**
The Execution model receives an array of risk-adjusted `PortfolioTarget` objects from the **Risk Management** model and places trades in the market to satisfy the targets. The Execution model only receives updates to the portfolio target share counts. It doesn't necessarily receive all of the targets at once.

The `ImmediateExecutionModel` is the default **Execution** model. It uses market orders to immediately fill portfolio targets. It's similar to placing market orders in line with your algorithm logic.
------
These module can be overwrite and put in a separate Python script within the project. We can import these modules and reuse it with different strategy. The beauty of this framework is allows us to break down the strategy development by small pieces so we can manage errors and update our strategy without affecting other part of the strategy. This is very crucial for a massive strategy with complex logics and conditions.

Summary
======
Summary for the article.

------
